# 0 "/home/andreas/git/arduino_lib/test/gpio/src/main.cpp"
# 1 "/home/andreas/git/arduino_lib/test/gpio//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/andreas/git/arduino_lib/test/gpio/src/main.cpp"
# 1 "/home/andreas/git/arduino_lib/test/../arduino_lib/Gpio.h" 1




# 1 "/home/andreas/git/arduino_lib/test/../arduino_lib/register_map.h" 1




# 1 "/home/andreas/git/arduino_lib/test/../arduino_lib/periph_base.h" 1




# 1 "/usr/lib/gcc/avr/11.2.0/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/avr/11.2.0/include/stdint.h" 3 4
# 1 "/usr/avr/include/stdint.h" 1 3 4
# 125 "/usr/avr/include/stdint.h" 3 4

# 125 "/usr/avr/include/stdint.h" 3 4
typedef signed int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef signed int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 146 "/usr/avr/include/stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 163 "/usr/avr/include/stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 217 "/usr/avr/include/stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 277 "/usr/avr/include/stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 10 "/usr/lib/gcc/avr/11.2.0/include/stdint.h" 2 3 4
# 6 "/home/andreas/git/arduino_lib/test/../arduino_lib/periph_base.h" 2



# 8 "/home/andreas/git/arduino_lib/test/../arduino_lib/periph_base.h"
namespace periph {


enum class Port {B, C, D};
enum class Pin {_0, _1, _2, _3, _4, _5, _6, _7};
enum class Direction {in, out};

template<typename EnumT_>
constexpr inline uint16_t get_num(EnumT_ val) { return static_cast<uint16_t>(val); }


};
# 6 "/home/andreas/git/arduino_lib/test/../arduino_lib/register_map.h" 2
# 1 "/home/andreas/git/arduino_lib/test/../arduino_lib/Register.h" 1



# 1 "/home/andreas/git/arduino_lib/test/../arduino_lib/constexpr_util.h" 1




namespace periph { namespace periph_detail {


template<uint16_t Base_, uint16_t Exponent_>
struct constexpr_pow {
 constexpr static uint16_t value = Base_ * constexpr_pow<Base_, Exponent_ - 1>::value;
};

template<uint16_t Base_>
struct constexpr_pow<Base_, 0> {
 constexpr static uint16_t value = 1;
};


template<uint16_t Value_, uint16_t Bits_>
struct has_no_more_bits {
 constexpr static uint16_t value = ( (Value_ & ~(constexpr_pow<2, Bits_>::value - 1)) == 0 );
};


}}
# 5 "/home/andreas/git/arduino_lib/test/../arduino_lib/Register.h" 2

# 1 "/home/andreas/git/arduino_lib/test/../arduino_lib/type_traits.h" 1




namespace std {


template<bool B>
struct enable_if;

template <> struct enable_if<true> { using type = void; };
template <> struct enable_if<false> {};


}
# 7 "/home/andreas/git/arduino_lib/test/../arduino_lib/Register.h" 2




namespace periph { namespace periph_detail {


using uint_single_t = uint8_t;
using uint_double_t = uint16_t;
# 25 "/home/andreas/git/arduino_lib/test/../arduino_lib/Register.h"
template<uint_single_t Length_>
struct requires_double_int_t {
    static_assert(Length_ <= sizeof(uint_double_t) * 8,
                  "Length too long even for double int type");

    enum {value = (Length_ > sizeof(uint_single_t)*8)};
};


template <uint_single_t Length_, typename T = void>
struct required_int_t {
    using type = uint_single_t;
};

template <uint_single_t Length_>
struct required_int_t<
    Length_,
    typename std::enable_if<requires_double_int_t<Length_>::value>::type> {

    using type = uint_double_t;
};
# 55 "/home/andreas/git/arduino_lib/test/../arduino_lib/Register.h"
template <typename Register_, uint8_t StartBit_, uint8_t Length_>
class RegisterValue {
private:
    using uint_t = typename required_int_t<Length_>::type;

    static volatile uint_t* get_addr_ptr() {
        return reinterpret_cast<volatile uint_t*>(Register_::address);
    }

public:
    template <uint_double_t Value> static void write() {
        static_assert(has_no_more_bits<Value, Length_>::value,
                      "More bits written to register value then it is long");

        write(static_cast<uint_t>(Value));
    }

    static void write(uint_t value) {
        constexpr static uint_t mask =
            ~(static_cast<uint_t>(constexpr_pow<2, Length_>::value - 1) << StartBit_);

        uint_t data = *get_addr_ptr();
        data = data & mask;
        data = data | (value << StartBit_);

        *get_addr_ptr() = data;
    }

    template <typename T> static T read_as() {
        constexpr uint_t mask =
            (~0u >> (16u - StartBit_ - Length_)) - ~(~0u << StartBit_);

        uint_t data = *get_addr_ptr();
        data = (data & mask) >> StartBit_;

        return static_cast<T>(data);
    }
};


}}
# 7 "/home/andreas/git/arduino_lib/test/../arduino_lib/register_map.h" 2


namespace periph { namespace periph_detail {


struct gpio_register_set {
 struct MCUCR {
  constexpr static uint8_t address = 0x55;

  using IVCE = RegisterValue<MCUCR, 0, 1>;
  using IVSEL = RegisterValue<MCUCR, 1, 1>;
  using PUD = RegisterValue<MCUCR, 4, 1>;
  using BODSE = RegisterValue<MCUCR, 5, 1>;
  using BODS = RegisterValue<MCUCR, 6, 1>;
 };

 template<Port Port_>
 struct PORTx {
  constexpr static uint8_t address = 0x25 + 4*get_num(Port_);

  template<Pin Pin_>
  using PORTxn = RegisterValue<PORTx<Port_>, get_num(Pin_), 1>;
 };

 template<Port Port_>
 struct DDRx {
  constexpr static uint8_t address = 0x24;

  template<Pin Pin_>
  using DDxn = RegisterValue<DDRx<Port_>, get_num(Pin_), 1>;
 };

 template<Port Port_>
 struct PINx {
  constexpr static uint8_t address = 0x24;

  template<Pin Pin_>
  using PINxn = RegisterValue<PINx<Port_>, get_num(Pin_), 1>;
 };
};


}}
# 6 "/home/andreas/git/arduino_lib/test/../arduino_lib/Gpio.h" 2


namespace periph {


template<Port Port_, Pin Pin_, Direction Direction_>
class Gpio {

 using reg = periph_detail::gpio_register_set;

public:
 Gpio() {
  set_direction();
 }

 void write(bool value) {
  static_assert(Direction_ == Direction::out, "Only output pins can be written to");
  reg::PORTx<Port_>::template PORTxn<Pin_>::write(value);
 }

 bool read() {
  if constexpr (Direction_ == Direction::out) {
   return reg::PORTx<Port_>::template PORTxn<Pin_>::template read_as<bool>();
  } else {

   return reg::PINx<Port_>::template PINxn<Pin_>::template read_as<bool>();
  }
 }
private:
 void set_direction() {
  if constexpr (Direction_ == Direction::out) {
   reg::DDRx<Port_>::template DDxn<Pin_>::template write<1>();
  } else {
   reg::DDRx<Port_>::template DDxn<Pin_>::template write<0>();
  }
 }
};


}
# 2 "/home/andreas/git/arduino_lib/test/gpio/src/main.cpp" 2


using namespace periph;


int main() {
    Gpio<Port::B, Pin::_6, Direction::out> led;

    led.write(1);

    return 0;
}
